% ______________________________________________________________________________
%
%   1DV600 - Software Technology
%   Assignment 3 -- "Testing"
%
%  Author:  Jonas Sj√∂berg
%           Linnaeus University
%           js224eh@student.lnu.se
%           https://github.com/jonasjberg
%
%    Date:  2017-03-03 -- 2017-03-05
%
% License:  Creative Commons Attribution 4.0 International (CC BY 4.0)
%           <http://creativecommons.org/licenses/by/4.0/legalcode>
%           See LICENSE.md for additional licensing information.
% ______________________________________________________________________________


% ______________________________________________________________________________
\section{Task 3 -- Unit Tests}

\paragraph{Instructions}\label{task-1-instructions}
from the course Wiki\cite{1dv600:lab3:instructions}:

\begin{quote}
    Create the unit tests necessary to perform the test cases that you have
    developed in task 2. You will find some examples of how this is done in the
    file PingTest in the system. All tests will be executed when you perform a
    vagrant reloadand if a test fails, the building will stop. Also, write down
    your reflections on unit tests with about 100 words.
\end{quote}



% ______________________________________________________________________________
\subsection{Units Tests}\label{task-2a}
The tests are included in the source code for this report.


\subsection{Reflections}\label{task-3-reflect}
% TODO: Reflect 
% TODO: The below is copied form task 2!
I have done a lot of TDD and unittesting in various previous projects.  Some
tests can be very difficult to set up so that the test results actually reflect
back on whether the code under test \emph{actually} performs as intended or
not. It is difficult to have full test coverage\cite{wiki:code-coverage}, and
even if you manage to acheive a very high coverage, there might be parts of the
code that is simply impossible to test. This is very context-depdendent and
vary with programming languages, executing platform, complications caused by
multi-threading, parallellizing, etc. There could be some state of the program
that would require testing the underlying interpreter or virtual machine. Even
if the entire project is built on open source code, some complex states are
often still practically unreachable due to budget constraints.

I usually apply testing to where it makes sense and the time required to
implement the testing is justifiable. I have tried all-out TDD, striving for
$100%$ coverage, and I have concluded that a lot of code makes little sense to
test, while other parts really demands extensive testing if the project is to
be taken at all seriously.


